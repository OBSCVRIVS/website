<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Admin · Notes</title>
  <link rel="stylesheet" href="styles.css">
  <meta name="theme-color" content="#FFFFFF">
  <script>
    (function(){
      var t = localStorage.getItem('theme') || 'auto';
      var initial = (t==='light'||t==='dark')
        ? t
        : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', initial);
    })();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js" defer></script>
</head>
<body>
<main class="container">
  <header class="flex-between">
    <h1>Admin</h1>
    <label class="muted">Theme:
      <select id="theme-select">
        <option value="auto">Auto (sunrise/sunset)</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>
    </label>
  </header>

  <!-- Auth -->
  <section class="card" style="margin-bottom:1rem">
    <h2 style="margin-top:0">Authentication</h2>
    <div class="grid-2">
      <div>
        <label>
          <span class="muted">Username</span>
          <input id="username" type="text" placeholder="e.g. levi" autocomplete="username">
        </label>
        <div style="margin-top:.5rem;display:flex;gap:.5rem;flex-wrap:wrap">
          <button id="btn-register" class="btn ghost">Register Passkey</button>
          <button id="btn-login" class="btn primary">Sign in with Passkey</button>
          <button id="btn-logout" class="btn ghost">Sign out</button>
        </div>
        <div id="remembered" style="margin-top:.75rem"></div>
      </div>
      <div>
        <div class="muted">Status</div>
        <div id="auth-state">Signed out</div>
        <div id="auth-user" class="muted"></div>
      </div>
    </div>
  </section>

  <!-- Composer -->
  <section id="composer" class="card" style="margin-bottom:1rem;display:none">
    <h2 style="margin-top:0">New Note</h2>
    <form id="note-form" class="grid-2">
      <label>
        <span>Markdown</span>
        <textarea id="body" rows="18" placeholder="Write Markdown…"></textarea>
      </label>
      <section>
        <header class="muted">Preview</header>
        <article id="preview" class="tweet__text card" style="min-height:18rem"></article>
      </section>
      <div class="muted" style="grid-column:1/-1">
        Timestamp set on save (UTC ISO + your IANA time zone). 24-hour time shown on site.
      </div>
      <div>
        <button type="submit" class="btn primary">Save</button>
      </div>
    </form>
  </section>

  <!-- Posts -->
  <section id="posts" class="card" style="display:none">
    <div class="flex-between" style="margin-bottom:.5rem">
      <h2 style="margin:0">Posts</h2>
      <div style="display:flex;gap:.5rem">
        <button id="btn-reload" class="btn ghost">Reload</button>
        <label class="muted" style="display:inline-flex;align-items:center;gap:.35rem">
          <input id="show-hidden" type="checkbox"> Show hidden
        </label>
      </div>
    </div>
    <div id="posts-list" class="card" style="padding:0"></div>
  </section>

  <!-- Debug -->
  <section class="card" style="margin-top:1rem">
    <h2 style="margin-top:0">Debug</h2>
    <div style="display:flex;gap:.5rem;flex-wrap:wrap;margin-bottom:.5rem">
      <button id="dbg-ping" class="btn ghost">Ping API</button>
      <button id="dbg-session" class="btn ghost">Show Session</button>
      <button id="dbg-clear" class="btn ghost">Clear Log</button>
    </div>
    <textarea id="debug" rows="10" class="card" style="width:100%;background:var(--field)"></textarea>
  </section>
</main>

<script>
/* ===== Utils ===== */
const $ = s => document.querySelector(s);
const dbg = $('#debug');
function log(...args){ if(!dbg) return; dbg.value += args.map(v=>typeof v==='string'?v:JSON.stringify(v,null,2)).join(' ') + "\n"; dbg.scrollTop = dbg.scrollHeight; }

/* ===== API (origin-based) ===== */
const ORIGIN = window.location.origin;
async function api(path, opts={}){
  const url = `${ORIGIN}/${String(path).replace(/^\//,'')}`;
  const res = await fetch(url, opts);
  const raw = await res.text();
  let data; try { data = JSON.parse(raw); } catch { data = { raw }; }
  if (!res.ok){ const msg = `${res.status} ${res.statusText} @ ${url}`; log('API error →', msg); throw new Error(msg); }
  return data;
}

/* ===== Time ===== */
function fmtLocal(iso, tz){
  const d = new Date(iso);
  const zone = tz || Intl.DateTimeFormat().resolvedOptions().timeZone;
  const ds = d.toLocaleString(undefined, { year:'numeric', month:'short', day:'2-digit', timeZone: zone });
  const ts = d.toLocaleTimeString(undefined, { hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false, timeZone: zone });
  const tzLabel = new Intl.DateTimeFormat(undefined, { timeZoneName:'short', timeZone: zone })
    .formatToParts(d).find(p=>p.type==='timeZoneName')?.value || zone;
  return `${ds} ${ts} ${tzLabel}`;
}

/* ===== Theme ===== */
(function () {
  const CONFIG = { lat: 34.0522, lon: -118.2437 };
  const selectEl = $("#theme-select");
  function sunTimes(date, lat, lon) {
    const rad = Math.PI/180, dayMs = 86400000;
    const dateUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
    const J2000 = 946684800000;
    const n = Math.round(((dateUTC - J2000)/dayMs) - (lon/360));
    const Jstar = n + lon/360 + 0.0008 + (2440587.5 - 2451545);
    function solNoon(){ const M = (357.5291 + 0.98560028 * (Jstar - 2451545)) % 360;
      const C = 1.9148*Math.sin(M*rad) + 0.0200*Math.sin(2*M*rad) + 0.0003*Math.sin(3*M*rad);
      const L = (M + 102.9372 + C + 180) % 360;
      return 2451545 + Jstar + 0.0053*Math.sin(M*rad) - 0.0069*Math.sin(2*L*rad); }
    function hourAngle(){ const M = (357.5291 + 0.98560028 * (Jstar - 2451545)) % 360;
      const C = 1.9148*Math.sin(M*rad) + 0.0200*Math.sin(2*M*rad) + 0.0003*Math.sin(3*M*rad);
      const L = (M + 102.9372 + C + 180) % 360;
      const δ = Math.asin(Math.sin(L*rad)*Math.sin(23.44*rad));
      const φ = lat*rad, h0 = (-6)*rad;
      const cosH = (Math.sin(h0) - Math.sin(φ)*Math.sin(δ)) / (Math.cos(φ)*Math.cos(δ));
      if (cosH <= -1) return Math.PI; if (cosH >= 1) return 0; return Math.acos(cosH); }
    function jdToDate(jd){ return new Date((jd - 2440587.5)*86400000); }
    const Jnoon = solNoon(); const H = hourAngle();
    return { sunrise: jdToDate(Jnoon - (H/(2*Math.PI))), sunset: jdToDate(Jnoon + (H/(2*Math.PI))) };
  }
  function isNightNow(lat, lon){ const now = new Date(); const { sunrise, sunset } = sunTimes(now, lat, lon); return (now < sunrise) || (now > sunset); }
  function systemPrefersDark(){ return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches; }
  function applyTheme(theme){
    const html = document.documentElement;
    let resolved = theme === "auto" ? (isNightNow(CONFIG.lat, CONFIG.lon) ? "dark" : "light") : theme;
    if (theme === "auto") { try{}catch{} if (!resolved) resolved = systemPrefersDark() ? "dark" : "light"; }
    html.setAttribute("data-theme", resolved);
    const bg = getComputedStyle(html).getPropertyValue("--bg").trim();
    let meta = document.querySelector('meta[name="theme-color"]'); if (!meta) { meta = document.createElement("meta"); meta.name = "theme-color"; document.head.appendChild(meta); }
    meta.setAttribute("content", bg);
  }
  const saved = localStorage.getItem("theme") || "auto"; applyTheme(saved);
  selectEl?.addEventListener("change", (e) => { const v = e.target.value; localStorage.setItem("theme", v); applyTheme(v); });
  if (window.matchMedia) window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => { if ((localStorage.getItem("theme") || "auto") === "auto") applyTheme("auto"); });
  setInterval(() => { if ((localStorage.getItem("theme") || "auto") === "auto") applyTheme("auto"); }, 3600000);
})();

/* ===== Markdown preview ===== */
const bodyEl = $('#body'); const previewEl = $('#preview');
function renderPreview(){
  if (!bodyEl || !previewEl) return;
  marked.setOptions({ gfm:true, breaks:false, headerIds:true, mangle:false });
  const html = marked.parse(bodyEl.value || "");
  previewEl.innerHTML = DOMPurify.sanitize(html, { ADD_ATTR:['target','rel'], FORBID_TAGS:['script','style'] });
  previewEl.querySelectorAll('a').forEach(a=>{ a.target='_blank'; a.rel='noopener noreferrer'; });
}
document.addEventListener('DOMContentLoaded', () => { bodyEl?.addEventListener('input', renderPreview); renderPreview(); });

/* ===== Session + auth UI ===== */
const UI = {
  composer: $('#composer'), posts: $('#posts'),
  authState: $('#auth-state'), authUser: $('#auth-user'),
  btnRegister: $('#btn-register'), btnLogin: $('#btn-login'), btnLogout: $('#btn-logout'),
  username: $('#username'), remembered: $('#remembered')
};
const SESSION_KEY = 'admin_token'; const USERS_KEY = 'admin_usernames';
function getSession(){ return localStorage.getItem(SESSION_KEY) || null; }
function setSession(token){ if (token) localStorage.setItem(SESSION_KEY, token); else localStorage.removeItem(SESSION_KEY); refreshAuthUI(); }
function getSavedUsers(){ try{ return JSON.parse(localStorage.getItem(USERS_KEY)||'[]'); }catch{ return []; } }
function saveUser(u){ if (!u) return; const set = new Set(getSavedUsers().concat([u])); localStorage.setItem(USERS_KEY, JSON.stringify([...set])); renderSavedUsers(); }
function renderSavedUsers(){ const list = getSavedUsers(); if (!UI.remembered) return;
  if (!list.length){ UI.remembered.innerHTML = ''; return; }
  UI.remembered.innerHTML = '<div class="muted">Quick login:</div>' + list.map(u => `<button class="btn ghost" data-u="${u}">${u}</button>`).join(' ');
  UI.remembered.querySelectorAll('button').forEach(b=>{ b.addEventListener('click', ()=>{ UI.username.value = b.dataset.u; passkeyLogin(); }); });
}
function refreshAuthUI(){ const authed = !!getSession();
  UI.composer.style.display = authed ? 'block' : 'none';
  UI.posts.style.display = authed ? 'block' : 'none';
  UI.authState.textContent = authed ? 'Signed in' : 'Signed out';
}

/* ===== WebAuthn helpers ===== */
function b64urlToBuf(b64url){ const pad = '='.repeat((4 - b64url.length % 4) % 4);
  const b64 = (b64url.replace(/-/g,'+').replace(/_/g,'/')) + pad; const raw = atob(b64);
  const buf = new ArrayBuffer(raw.length); const view = new Uint8Array(buf);
  for (let i=0;i<raw.length;i++) view[i] = raw.charCodeAt(i); return buf; }
function bufToB64url(buf){ const bytes = new Uint8Array(buf); let bin=''; for (let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
  return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }

/* ===== Endpoint resolvers ===== */
const BASES = ['', 'api']; // try root first, then /api

// --- WebAuthn options/verify (already working for you) ---
async function fetchJSON(url, init){ return api(url, init); }
function addUserParam(url, username){
  if (!username) return url;
  const u = new URL(url, ORIGIN);
  u.searchParams.set('username', username.toLowerCase().trim());
  return u.pathname + u.search;
}
async function waOptions(flow, payload){
  const username = (UI.username?.value || '').trim();
  for (const b of BASES){
    const base = b? `/${b}` : '';
    try { return { data: await fetchJSON(`${base}/webauthn/${flow}/options`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }) }; } catch{}
    try { return { data: await fetchJSON(addUserParam(`${base}/webauthn/${flow}/options`, username), { method:'GET' }) }; } catch{}
    try { return { data: await fetchJSON(`${base}/webauthn/${flow}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }) }; } catch{}
  }
  throw new Error('No options endpoint');
}
async function waVerify(flow, payload){
  for (const b of BASES){
    const base = b? `/${b}` : '';
    try { return { data: await fetchJSON(`${base}/webauthn/${flow}/verify`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }) }; } catch{}
    try { return { data: await fetchJSON(`${base}/webauthn/${flow}`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }) }; } catch{}
  }
  throw new Error('No verify endpoint');
}

/* --- Notes endpoints (probe root and /api) --- */
async function notesCreate(payload, token){
  const attempts=[];
  for (const b of BASES){
    const base = b? `/${b}` : '';
    try {
      return await fetchJSON(`${base}/notes`, {
        method:'POST',
        headers:{ 'Content-Type':'application/json', ...(token? {Authorization:`Bearer ${token}`} : {}) },
        body: JSON.stringify(payload)
      });
    } catch(e){ attempts.push(`${base||'/'}notes → ${e.message}`); }
  }
  log('notesCreate attempts:', attempts); throw new Error('No notes POST endpoint');
}
async function notesList(token){
  for (const b of BASES){
    const base = b? `/${b}` : '';
    try { return await fetchJSON(`${base}/notes?all=1`, { headers:{ ...(token? {Authorization:`Bearer ${token}`} : {}) } }); } catch{}
  }
  throw new Error('No notes GET endpoint');
}
async function notesPatch(id, body, token){
  for (const b of BASES){
    const base = b? `/${b}` : '';
    try {
      return await fetchJSON(`${base}/notes/${encodeURIComponent(id)}`, {
        method:'PATCH',
        headers:{ 'Content-Type':'application/json', ...(token? {Authorization:`Bearer ${token}`} : {}) },
        body: JSON.stringify(body)
      });
    } catch{}
  }
  throw new Error('No notes PATCH endpoint');
}
async function notesDelete(id, token){
  for (const b of BASES){
    const base = b? `/${b}` : '';
    try {
      return await fetchJSON(`${base}/notes/${encodeURIComponent(id)}`, {
        method:'DELETE',
        headers:{ ...(token? {Authorization:`Bearer ${token}`} : {}) }
      });
    } catch{}
  }
  throw new Error('No notes DELETE endpoint');
}

/* ===== Passkey flows ===== */
async function passkeyRegister(){
  try{
    const username = UI.username.value.trim(); if (!username) { alert('Enter a username.'); return; }
    const { data } = await waOptions('register', { username });
    const pk = data?.publicKey || data; if (!pk?.challenge) throw new Error('No publicKey in response');
    pk.challenge = b64urlToBuf(pk.challenge);
    if (pk.user?.id) pk.user.id = b64urlToBuf(pk.user.id);
    if (pk.excludeCredentials) pk.excludeCredentials = pk.excludeCredentials.map(c=>({ ...c, id: b64urlToBuf(c.id) }));
    const cred = await navigator.credentials.create({ publicKey: pk });
    const { data: out } = await waVerify('register', {
      id: cred.id, rawId: bufToB64url(cred.rawId), type: cred.type,
      response: { attestationObject: bufToB64url(cred.response.attestationObject), clientDataJSON: bufToB64url(cred.response.clientDataJSON) }
    });
    if (!out?.ok) throw new Error('Registration verify failed');
    alert('Passkey registered.'); saveUser(username);
  }catch(e){ log('register error:', e?.message || e); alert('Register failed'); }
}
async function passkeyLogin(){
  try{
    const username = UI.username.value.trim();
    const { data } = await waOptions('login', { username });
    const pk = data?.publicKey || data; if (!pk?.challenge) throw new Error('No publicKey in response');
    pk.challenge = b64urlToBuf(pk.challenge);
    if (pk.allowCredentials) pk.allowCredentials = pk.allowCredentials.map(c=>({ ...c, id: b64urlToBuf(c.id) }));
    const cred = await navigator.credentials.get({ publicKey: pk });
    const { data: out } = await waVerify('login', {
      id: cred.id, rawId: bufToB64url(cred.rawId), type: cred.type,
      response: { authenticatorData: bufToB64url(cred.response.authenticatorData), clientDataJSON: bufToB64url(cred.response.clientDataJSON), signature: bufToB64url(cred.response.signature), userHandle: cred.response.userHandle ? bufToB64url(cred.response.userHandle) : null }
    });
    if (!out?.ok) throw new Error('Login verify failed');
    setSession(out.token || 'ok'); UI.authUser.textContent = out.user?.username ? `User: ${out.user.username}` : '';
    if (username) saveUser(username); await loadPosts();
  }catch(e){ log('login error:', e?.message || e); alert('Login failed'); }
}

/* ===== Wire ===== */
UI.btnRegister?.addEventListener('click', passkeyRegister);
UI.btnLogin?.addEventListener('click', passkeyLogin);
UI.btnLogout?.addEventListener('click', ()=>{ setSession(null); UI.authUser.textContent=''; });
renderSavedUsers(); refreshAuthUI();

/* ===== Debug ===== */
$('#dbg-ping')?.addEventListener('click', async ()=>{
  const tries = ['/health','/api/health'];
  for (const t of tries) {
    try { const j = await api(t); log('ping →', t, j); return; } catch(e){ log('ping error →', t, e?.message||e); }
  }
});
$('#dbg-session')?.addEventListener('click', ()=> log('session →', { token: getSession(), origin: ORIGIN }));
$('#dbg-clear')?.addEventListener('click', ()=> { if(dbg) dbg.value=''; });

/* ===== Notes ===== */
const postsBox = $('#posts-list'); const showHidden = $('#show-hidden');
$('#btn-reload')?.addEventListener('click', loadPosts);
showHidden?.addEventListener('change', ()=> renderPosts(window.__NOTES || []));
$('#note-form')?.addEventListener('submit', async (e)=>{
  e.preventDefault();
  const token = getSession(); if (!token) { alert('Sign in first.'); return; }
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const payload = { body: ($('#body')?.value || ''), created_at: new Date().toISOString(), tz };
  try{
    await notesCreate(payload, token);
    alert('Saved.');
    $('#body').value = ''; renderPreview();
    await loadPosts();
  }catch(err){ log('save error:', err?.message || err); alert('Save failed'); }
});
async function loadPosts(){
  const token = getSession(); if (!token) return;
  try{
    const notes = await notesList(token);
    window.__NOTES = Array.isArray(notes) ? notes : [];
    renderPosts(window.__NOTES);
  }catch(e){ log('load posts error →', e?.message || e); postsBox.innerHTML = '<div class="muted" style="padding:1rem">Could not load posts.</div>'; }
}
function renderPosts(notes){
  if (!postsBox) return;
  const visible = showHidden?.checked ? notes : notes.filter(n=>!n.hidden);
  if (!visible.length){ postsBox.innerHTML = '<div class="muted" style="padding:1rem">No posts.</div>'; return; }
  const rows = visible.map(n=>{
    const when = fmtLocal(n.created_at, n.tz);
    return `
      <div style="display:flex;gap:.75rem;align-items:center;padding:.6rem 1rem;border-top:1px solid var(--field-border)">
        <div style="flex:1;overflow:hidden">
          <div><strong>${n.id}</strong></div>
          <div class="muted" style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${when} · ${n.tz || ''}</div>
          ${n.hidden ? '<div class="muted">Hidden</div>' : ''}
        </div>
        <div style="display:flex;gap:.5rem">
          <button class="btn ghost" data-act="toggle" data-id="${n.id}" data-hidden="${n.hidden?1:0}">${n.hidden?'Unhide':'Hide'}</button>
          <button class="btn ghost" data-act="delete" data-id="${n.id}">Delete</button>
        </div>
      </div>`;
  }).join('');
  postsBox.innerHTML = rows;
  postsBox.querySelectorAll('button[data-act="toggle"]').forEach(b=>{
    b.addEventListener('click', async ()=>{
      const id = b.getAttribute('data-id');
      const hidden = b.getAttribute('data-hidden') === '1';
      try{ await notesPatch(id, { hidden: !hidden }, getSession()); await loadPosts(); } catch(e){ log('toggle error →', e?.message||e); alert('Failed to toggle'); }
    });
  });
  postsBox.querySelectorAll('button[data-act="delete"]').forEach(b=>{
    b.addEventListener('click', async ()=>{
      const id = b.getAttribute('data-id');
      if (!confirm('Delete this post?')) return;
      try{ await notesDelete(id, getSession()); await loadPosts(); } catch(e){ log('delete error →', e?.message||e); alert('Failed to delete'); }
    });
  });
}

/* ===== Init ===== */
document.addEventListener('DOMContentLoaded', async ()=>{
  refreshAuthUI(); renderSavedUsers(); if (getSession()){ await loadPosts(); }
  localStorage.removeItem('API_BASE');
});
</script>
</body>
</html>
