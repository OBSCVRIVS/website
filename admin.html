<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Admin · Notes</title>
  <link rel="stylesheet" href="styles.css">
  <meta name="theme-color" content="#FFFFFF">

  <!-- Minimal, page-scoped styles for layout + icon + counter -->
  <style>
    .admin-wrap { max-width: 960px; margin: 2rem auto; padding: 1rem; }
    .admin-row { display:flex; justify-content:space-between; align-items:center; gap:1rem; }
    .admin-grid2 { display:grid; gap:1rem; grid-template-columns:1fr 1fr; }
    .admin-card { border:1px solid var(--field-border); padding:1rem; border-radius:4px; background:var(--field); }
    #posts-list .tweet { border: 0; border-top: 1px solid var(--field-border); margin: 0; }
    #posts-list .tweet:first-child { border-top: 0; }
    .permalink{ color:var(--muted); text-decoration:none; display:inline-flex; align-items:center; }
    .permalink:hover,.permalink:focus{ color:var(--accent); }
    .permalink svg{ width:16px; height:16px; display:block; }
    .sr-only{ position:absolute!important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

    /* Byte counter */
    .byte-row{ display:flex; justify-content:space-between; align-items:center; margin-top:.35rem; font-size:.9rem; }
    .byte-count{ font-variant-numeric: tabular-nums; }
    .ok{ color: var(--muted); }
    .warn{ color: #B26A00; }
    .bad{ color: #B00020; }
    .mini-actions{ display:flex; gap:.5rem; flex-wrap:wrap; }
    .mini-actions button{ padding:.3rem .55rem; font-size:.85rem; }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js" defer></script>
</head>
<body>
<main class="admin-wrap">
  <header class="admin-row">
    <h1>Admin</h1>
  </header>

  <!-- Auth -->
  <section class="admin-card" style="margin-bottom:1rem">
    <h2 style="margin-top:0">Authentication</h2>
    <div class="admin-grid2">
      <div>
        <label>
          <span class="muted">Username</span>
          <input id="username" type="text" placeholder="e.g. levi" autocomplete="username">
        </label>
        <div style="margin-top:.5rem;display:flex;gap:.5rem;flex-wrap:wrap">
          <button id="btn-register" class="btn ghost">Register Passkey</button>
          <button id="btn-login" class="btn primary">Sign in with Passkey</button>
          <button id="btn-logout" class="btn ghost">Sign out</button>
        </div>
        <div id="remembered" style="margin-top:.75rem"></div>
      </div>
      <div>
        <div class="muted">Status</div>
        <div id="auth-state">Signed out</div>
        <div id="auth-user" class="muted"></div>
      </div>
    </div>
  </section>

  <!-- Composer -->
  <section id="composer" class="admin-card" style="margin-bottom:1rem;display:none">
    <h2 style="margin-top:0">New Note</h2>
    <form id="note-form" class="admin-grid2">
      <label>
        <span>Markdown</span>
        <textarea id="body" rows="18" placeholder="Write Markdown…"></textarea>

        <!-- live byte counter + quick tools -->
        <div class="byte-row">
          <div class="mini-actions">
            <button type="button" id="btn-trim" class="btn ghost">Trim</button>
            <button type="button" id="btn-collapse" class="btn ghost">Collapse blanks</button>
          </div>
          <div class="byte-count ok">
            <span id="byte-now">0</span>/<span id="byte-max">90000</span> bytes
          </div>
        </div>
      </label>

      <section>
        <header class="muted">Preview</header>
        <article id="preview" class="tweet__text admin-card" style="min-height:18rem"></article>
      </section>

      <div class="muted" style="grid-column:1/-1">
        Timestamp set on save (UTC ISO + your IANA time zone). 24-hour time shown on site.
      </div>
      <div>
        <button type="submit" id="btn-post" class="btn primary">Post</button>
      </div>
    </form>
  </section>

  <!-- Posts -->
  <section id="posts" class="admin-card" style="display:none">
    <div class="admin-row" style="margin-bottom:.5rem">
      <h2 style="margin:0">Posts</h2>
      <button id="btn-reload" class="btn ghost">Reload</button>
    </div>
    <div id="posts-list" class="admin-card" style="padding:0"></div>
  </section>

  <!-- Debug -->
  <section class="admin-card" style="margin-top:1rem">
    <h2 style="margin-top:0">Debug</h2>
    <div style="display:flex;gap:.5rem;flex-wrap:wrap;margin-bottom:.5rem">
      <button id="dbg-ping" class="btn ghost">Ping API</button>
      <button id="dbg-session" class="btn ghost">Show Session</button>
      <button id="dbg-clear" class="btn ghost">Clear Log</button>
    </div>
    <textarea id="debug" rows="10" class="admin-card" style="width:100%;background:var(--field)"></textarea>
  </section>
</main>

<script>
/* ===== Utils ===== */
const $ = s => document.querySelector(s);
const dbg = $('#debug');
function log(...args){ if(!dbg) return; dbg.value += args.map(v=>typeof v==='string'?v:JSON.stringify(v,null,2)).join(' ') + "\n"; dbg.scrollTop = dbg.scrollHeight; }

/* ===== API (origin-based) ===== */
const ORIGIN = window.location.origin;
async function api(path, opts={}){
  const url = `${ORIGIN}/${String(path).replace(/^\//,'')}`;
  const res = await fetch(url, opts);
  const raw = await res.text();
  let data; try { data = JSON.parse(raw); } catch { data = { raw }; }
  if (!res.ok){ const msg = `${res.status} ${res.statusText} @ ${url}`; log('API error →', msg); throw new Error(msg); }
  return data;
}

/* ===== Time ===== */
function fmtLocal(iso, tz){
  const d = new Date(iso);
  const zone = tz || Intl.DateTimeFormat().resolvedOptions().timeZone;
  const ds = d.toLocaleString(undefined, { year:'numeric', month:'short', day:'2-digit', timeZone: zone });
  const ts = d.toLocaleTimeString(undefined, { hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false, timeZone: zone });
  const tzLabel = new Intl.DateTimeFormat(undefined, { timeZoneName:'short', timeZone: zone })
    .formatToParts(d).find(p=>p.type==='timeZoneName')?.value || zone;
  return `${ds} ${ts} ${tzLabel}`;
}

/* ===== Theme: auto by local clock (no geo) ===== */
(function () {
  const LIGHT_START_H = 7, LIGHT_END_H = 19;
  function applyThemeByClock() {
    const h = new Date().getHours();
    const mode = (h >= LIGHT_START_H && h < LIGHT_END_H) ? 'light' : 'dark';
    const html = document.documentElement;
    html.setAttribute('data-theme', mode);
    const bg = getComputedStyle(html).getPropertyValue('--bg').trim();
    let meta = document.querySelector('meta[name="theme-color"]');
    if (!meta) { meta = document.createElement('meta'); meta.name = 'theme-color'; document.head.appendChild(meta); }
    meta.setAttribute('content', bg);
  }
  applyThemeByClock();
  setInterval(applyThemeByClock, 15 * 60 * 1000);
})();

/* ===== Markdown preview ===== */
const bodyEl = $('#body'); const previewEl = $('#preview');
function renderPreview(){
  if (!bodyEl || !previewEl) return;
  marked.setOptions({ gfm:true, breaks:false, headerIds:true, mangle:false });
  const html = marked.parse(bodyEl.value || "");
  previewEl.innerHTML = DOMPurify.sanitize(html, { ADD_ATTR:['target','rel'], FORBID_TAGS:['script','style'] });
  previewEl.querySelectorAll('a').forEach(a=>{ a.target='_blank'; a.rel='noopener noreferrer'; });
}

/* ===== Session + auth UI ===== */
const UI = {
  composer: $('#composer'), posts: $('#posts'),
  authState: $('#auth-state'), authUser: $('#auth-user'),
  btnRegister: $('#btn-register'), btnLogin: $('#btn-login'), btnLogout: $('#btn-logout'),
  username: $('#username'), remembered: $('#remembered')
};
const SESSION_KEY = 'admin_token'; const USERS_KEY = 'admin_usernames';
function getSession(){ return localStorage.getItem(SESSION_KEY) || null; }
function setSession(token){ if (token) localStorage.setItem(SESSION_KEY, token); else localStorage.removeItem(SESSION_KEY); refreshAuthUI(); }
function getSavedUsers(){ try{ return JSON.parse(localStorage.getItem(USERS_KEY)||'[]'); }catch{ return []; } }
function saveUser(u){ if (!u) return; const set = new Set(getSavedUsers().concat([u])); localStorage.setItem(USERS_KEY, JSON.stringify([...set])); renderSavedUsers(); }
function renderSavedUsers(){ const list = getSavedUsers(); if (!UI.remembered) return;
  if (!list.length){ UI.remembered.innerHTML = ''; return; }
  UI.remembered.innerHTML = '<div class="muted">Quick login:</div>' + list.map(u => `<button class="btn ghost" data-u="${u}">${u}</button>`).join(' ');
  UI.remembered.querySelectorAll('button').forEach(b=>{ b.addEventListener('click', ()=>{ UI.username.value = b.dataset.u; passkeyLogin(); }); });
}
function refreshAuthUI(){ const authed = !!getSession();
  UI.composer.style.display = authed ? 'block' : 'none';
  UI.posts.style.display = authed ? 'block' : 'none';
  UI.authState.textContent = authed ? 'Signed in' : 'Signed out';
}

/* ===== WebAuthn helpers ===== */
function b64urlToBuf(b64url){ const pad = '='.repeat((4 - b64url.length % 4) % 4);
  const b64 = (b64url.replace(/-/g,'+').replace(/_/g,'/')) + pad; const raw = atob(b64);
  const buf = new ArrayBuffer(raw.length); const view = new Uint8Array(buf);
  for (let i=0;i<raw.length;i++) view[i] = raw.charCodeAt(i); return buf; }
function bufToB64url(buf){ const bytes = new Uint8Array(buf); let bin=''; for (let i=0;i<bytes.length;i++) bin+=String.fromCharCode(bytes[i]);
  return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,''); }

/* ===== WebAuthn endpoints ===== */
async function fetchJSON(url, init){ return api(url, init); }
function addUserParam(url, username){
  const u = new URL(url, ORIGIN);
  if (username) u.searchParams.set('username', username.toLowerCase().trim());
  return u.pathname + u.search;
}
async function waOptions(flow){
  const username = (UI.username?.value || '').trim();
  try { return { data: await fetchJSON(addUserParam(`/webauthn/${flow}/options`, username), { method:'GET' }) }; } catch {}
  try { return { data: await fetchJSON(addUserParam(`/api/webauthn/${flow}/options`, username), { method:'GET' }) }; } catch {}
  throw new Error('No options endpoint');
}
async function waVerify(flow, payload){
  try { return { data: await fetchJSON(`/webauthn/${flow}/verify`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }) }; } catch {}
  try { return { data: await fetchJSON(`/api/webauthn/${flow}/verify`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) }) }; } catch {}
  throw new Error('No verify endpoint');
}

/* ===== Notes API (single endpoint, 413-aware) ===== */
async function notesCreate(payload){
  const ep = '/api/post';
  const res = await fetch(ep, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'Accept':'application/json' },
    body: JSON.stringify(payload)
  });
  if (res.status === 413) throw new Error('413 Payload Too Large'); // caller will shrink
  if (!res.ok) throw new Error(res.status + ' ' + res.statusText);
  const txt = await res.text();
  return txt ? JSON.parse(txt) : {};
}
async function notesList(){
  try { return await api('/api/notes?all=1'); } catch {}
  try { return await api('/notes?all=1'); } catch {}
  return await api('/api/notes');
}
async function notesDelete(id){
  const tries = [
    { url: `/notes/${encodeURIComponent(id)}`, method:'DELETE' },
    { url: `/api/notes/${encodeURIComponent(id)}`, method:'DELETE' },
    { url: `/notes/${encodeURIComponent(id)}`, method:'POST', body:{ action:'delete' } },
    { url: `/api/notes/${encodeURIComponent(id)}`, method:'POST', body:{ action:'delete' } },
  ];
  let lastErr;
  for (const t of tries){
    try{
      if (t.method === 'POST') {
        return await api(t.url, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(t.body) });
      }
      return await api(t.url, { method:t.method });
    }catch(e){ lastErr = e; }
  }
  throw lastErr || new Error('Delete failed');
}

/* ===== Posts (mirror frontend) ===== */
const postsBox = $('#posts-list');
$('#btn-reload')?.addEventListener('click', loadPosts);

function mdRender(src){
  marked.setOptions({ gfm:true, breaks:false, headerIds:true, mangle:false });
  const html = marked.parse(src || "");
  return DOMPurify.sanitize(html, { ADD_ATTR:['target','rel'], FORBID_TAGS:['script','style'] });
}
function renderPosts(notes){
  if (!postsBox) return;
  if (!Array.isArray(notes) || notes.length === 0){
    postsBox.innerHTML = '<div class="muted" style="padding:1rem">No posts.</div>';
    return;
  }
  postsBox.innerHTML = notes.map(n=>{
    const when = fmtLocal(n.created_at, n.tz);
    return `
      <article class="tweet" id="${n.id}" style="padding:1rem;border-top:1px solid var(--field-border)">
        <div style="display:flex;gap:1rem">
          <div class="tweet__avatar"><img src="assets/img/avatar_anime_blue_hour.png" alt="" aria-hidden="true"></div>
          <div class="tweet__body" style="flex:2">
            <header class="tweet__head">
              <span class="name">Levi Carver</span>
              <span class="dot" aria-hidden="true">·</span>
              <time datetime="${n.created_at}">${when}</time>
            </header>
            <div class="tweet__text">${mdRender(n.body)}</div>
          </div>
          <div style="flex:1;display:flex;justify-content:flex-end;align-items:flex-start;gap:.5rem">
            <a class="permalink" href="/notes.html?id=${encodeURIComponent(n.id)}" aria-label="Permalink">
              <svg viewBox="0 0 24 24" aria-hidden="true" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10.172 13.828a4 4 0 0 0 5.656 0l3-3a4 4 0 1 0-5.656-5.656l-1.172 1.172"/>
                <path d="M13.828 10.172a4 4 0 0 0-5.656 0l-3 3a4 4 0 1 0 5.656 5.656l1.172-1.172"/>
              </svg>
              <span class="sr-only">Permalink</span>
            </a>
            <button class="btn ghost" data-act="delete" data-id="${n.id}">Delete</button>
          </div>
        </div>
      </article>`;
  }).join('');
  postsBox.querySelectorAll('.tweet__text a').forEach(a=>{ a.target = '_blank'; a.rel = 'noopener noreferrer'; });
  postsBox.querySelectorAll('button[data-act="delete"]').forEach(b=>{
    b.addEventListener('click', async ()=>{
      const id = b.getAttribute('data-id');
      if (!confirm('Delete this post? This cannot be undone.')) return;
      try { await notesDelete(id); await loadPosts(); }
      catch(e){ log('delete error →', e?.message || e); alert('Failed to delete'); }
    });
  });
}

/* ===== Compose: ultra-safe sizes & split ===== */
const MAX_BYTES = 90000;            // UI reference only
let   SEND_CAP_START = 1500;        // initial cap (~1.5 KB)
const MIN_CAP = 500;                // smallest cap (~0.5 KB)
const SAFETY = 150;                 // metadata margin
const WARN_BYTES = Math.floor(MAX_BYTES * 0.8);
const enc = new TextEncoder();

const byteNowEl = $('#byte-now');
const byteMaxEl = $('#byte-max');
const btnPost = $('#btn-post');
const btnTrim = $('#btn-trim');
const btnCollapse = $('#btn-collapse');

function payloadBytes(body){
  const sample = { body, created_at: new Date().toISOString(), tz: Intl.DateTimeFormat().resolvedOptions().timeZone };
  return enc.encode(JSON.stringify(sample)).length;
}

/* hard UTF-8 byte slice: returns a string whose JSON payload <= maxBytes */
function sliceBodyToBytes(text, maxBytes){
  // binary search on char length, then trim on byte boundary
  let lo = 0, hi = text.length, cut = 0;
  while (lo <= hi){
    const mid = Math.floor((lo + hi) / 2);
    const piece = text.slice(0, mid);
    if (payloadBytes(piece) <= maxBytes){ cut = mid; lo = mid + 1; }
    else { hi = mid - 1; }
  }
  let out = text.slice(0, cut);
  // final safety: if still too big (edge cases), drop last char(s)
  while (out && payloadBytes(out) > maxBytes) out = out.slice(0, -1);
  return out;
}

/* splitter that guarantees each part <= maxBytes, falling back to byte-slice */
function splitByBytes(text, maxBytes){
  const parts = [];
  const paras = text.split(/\n{2,}/);
  let buf = '';
  const push = ()=>{
    if (!buf.trim()) return;
    if (payloadBytes(buf) <= maxBytes){ parts.push(buf.trim()); }
    else {
      // too large even after paragraph/sentence grouping → hard slice repeatedly
      let rest = buf.trim();
      while (rest){
        const chunk = sliceBodyToBytes(rest, maxBytes);
        if (!chunk) break;
        parts.push(chunk);
        rest = rest.slice(chunk.length);
      }
    }
    buf = '';
  };

  for (let i=0;i<paras.length;i++){
    const next = buf ? (buf + '\n\n' + paras[i]) : paras[i];
    if (payloadBytes(next) <= maxBytes){ buf = next; continue; }
    if (!buf){
      // split paragraph by sentences first
      const sents = paras[i].split(/(?<=[.!?])\s+(?=[A-Z(“"'\[])/);
      let sb = '';
      for (const s of sents){
        const cand = sb ? (sb + ' ' + s) : s;
        if (payloadBytes(cand) <= maxBytes){ sb = cand; }
        else {
          if (sb){ parts.push(sb.trim()); sb=''; }
          // hard slice this very long sentence
          let rest = s;
          while (payloadBytes(rest) > maxBytes){
            const chunk = sliceBodyToBytes(rest, maxBytes);
            parts.push(chunk.trim());
            rest = rest.slice(chunk.length);
          }
          if (rest.trim()) sb = rest;
        }
      }
      if (sb.trim()) parts.push(sb.trim());
    } else {
      push(); i--; // reprocess this paragraph as start of next part
    }
  }
  push();
  return parts;
}

function updateByteUI(){
  if (!bodyEl) return;
  const size = payloadBytes(bodyEl.value);
  byteNowEl.textContent = String(size);
  byteMaxEl.textContent = String(MAX_BYTES);
  const bc = byteNowEl.parentElement;
  bc.classList.remove('ok','warn','bad');
  if (size > MAX_BYTES) bc.classList.add('bad');
  else if (size > WARN_BYTES) bc.classList.add('warn');
  else bc.classList.add('ok');
  btnPost.disabled = false; // we auto-chunk anyway
}
function trimBody(){
  bodyEl.value = bodyEl.value.replace(/[ \t]+$/gm, '').replace(/^\n+|\n+$/g, '');
  renderPreview(); updateByteUI();
}
function collapseBlanks(){
  bodyEl.value = bodyEl.value.replace(/\n{3,}/g, '\n\n');
  renderPreview(); updateByteUI();
}

/* Wire preview + counter */
document.addEventListener('DOMContentLoaded', () => {
  renderPreview(); updateByteUI();
  bodyEl?.addEventListener('input', ()=>{ renderPreview(); updateByteUI(); });
  btnTrim?.addEventListener('click', trimBody);
  btnCollapse?.addEventListener('click', collapseBlanks);
});

/* ===== Save (adaptive backoff; guaranteed <= cap) ===== */
$('#note-form')?.addEventListener('submit', async (e)=>{
  e.preventDefault();
  trimBody(); collapseBlanks();

  const full = bodyEl.value || '';
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const btn = $('#btn-post'); const original = btn.textContent;
  btn.disabled = true;

  const sleep = ms => new Promise(r=>setTimeout(r, ms));

  async function postMulti(text, cap){
    const maxPayload = Math.max(MIN_CAP, cap - SAFETY);
    const parts = payloadBytes(text) > maxPayload ? splitByBytes(text, maxPayload) : [text];

    const base = new Date();
    for (let i=0;i<parts.length;i++){
      // final guard: enforce byte cap on each part
      let body = parts[i];
      if (payloadBytes(body) > maxPayload){
        body = sliceBodyToBytes(body, maxPayload);
      }
      const pfx = (parts.length > 1) ? `(Part ${i+1}/${parts.length})\n\n` : '';
      const payload = {
        body: pfx + body,
        created_at: new Date(base.getTime() + i*1000).toISOString(),
        tz
      };
      const size = payloadBytes(payload.body);
      log('posting chunk', i+1, '/', parts.length, 'bytes=', size);
      btn.textContent = `Posting ${i+1}/${parts.length}…`;
      await notesCreate(payload);            // throws on 413/other
      await sleep(250);                      // tiny pacing
    }
    return parts.length;
  }

  let cap = SEND_CAP_START;
  try{
    while (true){
      try{
        const posted = await postMulti(full, cap);
        alert(`Posted ${posted} part(s).`);
        bodyEl.value = ''; renderPreview(); updateByteUI();
        await loadPosts();
        break;
      }catch(err){
        const msg = String(err?.message || err);
        if (msg.includes('413') && cap > MIN_CAP){
          cap = Math.max(MIN_CAP, Math.floor(cap * 0.7)); // shrink and retry
          log('413 → shrinking cap to', cap);
          continue;
        }
        throw err; // non-413 or already at min cap
      }
    }
  }catch(err){
    alert(`Failed to post.\n${err?.message || err}`);
  }finally{
    btn.textContent = original;
    btn.disabled = false;
  }
});

/* ===== Load posts ===== */
async function loadPosts(){
  try{
    const notes = await notesList();
    window.__NOTES = Array.isArray(notes) ? notes : [];
    renderPosts(window.__NOTES);
  }catch(e){
    log('load posts error →', e?.message || e);
    postsBox.innerHTML = '<div class="muted" style="padding:1rem">Could not load posts.</div>';
  }
}

/* ===== Passkey flows ===== */
async function passkeyRegister(){
  try{
    const username = UI.username.value.trim(); if (!username) { alert('Enter a username.'); return; }
    const { data } = await waOptions('register');
    const pk = data?.publicKey || data; if (!pk?.challenge) throw new Error('No publicKey in response');
    pk.challenge = b64urlToBuf(pk.challenge);
    if (pk.user?.id) pk.user.id = b64urlToBuf(pk.user.id);
    if (pk.excludeCredentials) pk.excludeCredentials = pk.excludeCredentials.map(c=>({ ...c, id: b64urlToBuf(c.id) }));
    const cred = await navigator.credentials.create({ publicKey: pk });
    const { data: out } = await waVerify('register', {
      id: cred.id, rawId: bufToB64url(cred.rawId), type: cred.type,
      response: { attestationObject: bufToB64url(cred.response.attestationObject), clientDataJSON: bufToB64url(cred.response.clientDataJSON) }
    });
    if (!out?.ok) throw new Error('Registration verify failed');
    alert('Registered.');
    saveUser(username);
  }catch(e){ log('register error:', e?.message || e); alert('Register failed'); }
}
async function passkeyLogin(){
  try{
    const username = UI.username.value.trim();
    const { data } = await waOptions('login');
    const pk = data?.publicKey || data; if (!pk?.challenge) throw new Error('No publicKey in response');
    pk.challenge = b64urlToBuf(pk.challenge);
    if (pk.allowCredentials) pk.allowCredentials = pk.allowCredentials.map(c=>({ ...c, id: b64urlToBuf(c.id) }));
    const cred = await navigator.credentials.get({ publicKey: pk });
    const { data: out } = await waVerify('login', {
      id: cred.id, rawId: bufToB64url(cred.rawId), type: cred.type,
      response: { authenticatorData: bufToB64url(cred.response.authenticatorData), clientDataJSON: bufToB64url(cred.response.clientDataJSON), signature: bufToB64url(cred.response.signature), userHandle: cred.response.userHandle ? bufToB64url(cred.response.userHandle) : null }
    });
    if (!out?.ok) throw new Error('Login verify failed');
    setSession('ok'); UI.authUser.textContent = username ? `User: ${username}` : '';
    await loadPosts();
  }catch(e){ log('login error:', e?.message || e); alert('Login failed'); }
}

/* ===== Wire + init ===== */
UI.btnRegister?.addEventListener('click', passkeyRegister);
UI.btnLogin?.addEventListener('click', passkeyLogin);
UI.btnLogout?.addEventListener('click', ()=>{ setSession(null); UI.authUser.textContent=''; });
renderSavedUsers(); refreshAuthUI();

$('#dbg-ping')?.addEventListener('click', async ()=>{
  const tries = ['/health','/api/health'];
  for (const t of tries) { try { const j = await api(t); log('ping →', t, j); return; } catch(e){ log('ping error →', t, e?.message||e); } }
});
$('#dbg-session')?.addEventListener('click', ()=> log('session →', { token: getSession(), origin: ORIGIN }));
$('#dbg-clear')?.addEventListener('click', ()=> { if(dbg) dbg.value=''; });

document.addEventListener('DOMContentLoaded', async ()=>{
  refreshAuthUI(); renderPreview(); updateByteUI(); renderSavedUsers(); await loadPosts();
  localStorage.removeItem('API_BASE');
});
</script>
</body>
</html>
