<!doctype html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Admin · Notes</title>
  <link rel="stylesheet" href="styles.css">
  <meta name="theme-color" content="#FFFFFF">

  <!-- Early theme -->
  <script>
    (function(){
      var t = localStorage.getItem('theme') || 'auto';
      var initial = (t==='light'||t==='dark')
        ? t
        : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      document.documentElement.setAttribute('data-theme', initial);
    })();
  </script>

  <!-- Markdown + Sanitizer -->
  <script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.9/dist/purify.min.js" defer></script>
</head>
<body>
<main class="container">
  <header class="flex-between">
    <h1>Admin</h1>
    <label class="muted">
      Theme:
      <select id="theme-select">
        <option value="auto">Auto (sunrise/sunset)</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
      </select>
    </label>
  </header>

  <!-- Auth controls -->
  <section class="card" style="margin-bottom:1rem">
    <h2 style="margin-top:0">Authentication</h2>
    <p class="muted" style="margin:.25rem 0 1rem">
      Use a passkey to sign in. Registration is one-time.
    </p>
    <div style="display:flex;gap:.5rem;flex-wrap:wrap">
      <button id="btn-register" class="btn ghost">Register Passkey</button>
      <button id="btn-login" class="btn primary">Sign in with Passkey</button>
      <button id="btn-logout" class="btn ghost">Sign out</button>
      <span id="auth-state" class="muted" style="align-self:center"></span>
    </div>
  </section>

  <!-- Composer -->
  <section class="card" id="composer" style="margin-bottom:1rem; display:none">
    <h2 style="margin-top:0">New Note</h2>
    <form id="note-form" class="grid-2">
      <label>
        <span>Markdown</span>
        <textarea id="body" rows="18" placeholder="Write Markdown…"></textarea>
      </label>

      <section>
        <header class="muted">Preview</header>
        <article id="preview" class="tweet__text card" style="min-height:18rem"></article>
      </section>

      <!-- Auto timestamp: UTC + IANA tz -->
      <div class="muted" style="grid-column:1 / -1">
        Timestamp is set on save using your local time zone and ISO UTC.
      </div>

      <div>
        <button type="submit" class="btn primary">Save</button>
      </div>
    </form>
  </section>

  <!-- Debug -->
  <section class="card">
    <h2 style="margin-top:0">Debug</h2>
    <div style="display:flex;gap:.5rem;flex-wrap:wrap;margin-bottom:.5rem">
      <button id="dbg-ping" class="btn ghost">Ping API</button>
      <button id="dbg-session" class="btn ghost">Show Session</button>
      <button id="dbg-clear" class="btn ghost">Clear Log</button>
    </div>
    <textarea id="debug" rows="10" class="card" style="width:100%;background:var(--field)"></textarea>
  </section>
</main>

<script>
  // ---------- Markdown live preview ----------
  const bodyEl = document.getElementById('body');
  const previewEl = document.getElementById('preview');
  function renderPreview(){
    marked.setOptions({ gfm:true, breaks:false, headerIds:true, mangle:false });
    const html = marked.parse(bodyEl?.value || "");
    if (previewEl) {
      previewEl.innerHTML = DOMPurify.sanitize(html, {
        ADD_ATTR:['target','rel'],
        FORBID_TAGS:['script','style']
      });
      previewEl.querySelectorAll('a').forEach(a=>{ a.target='_blank'; a.rel='noopener noreferrer'; });
    }
  }
  document.addEventListener('DOMContentLoaded', () => {
    if (bodyEl) {
      bodyEl.addEventListener('input', renderPreview);
      renderPreview();
    }
  });

  // ---------- Minimal logger ----------
  const dbg = document.getElementById('debug');
  function log(...args){ if(dbg){ dbg.value += args.map(v=> typeof v==='string'? v : JSON.stringify(v,null,2)).join(' ') + "\n"; dbg.scrollTop = dbg.scrollHeight; } }

  // ---------- Theme control ----------
  (function () {
    const CONFIG = { lat: 34.0522, lon: -118.2437 };
    const STORAGE_KEY = "theme";
    const selectEl = document.getElementById("theme-select");

    function sunTimes(date, lat, lon) {
      const rad = Math.PI/180, dayMs = 86400000;
      const dateUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
      const J2000 = 946684800000;
      const n = Math.round(((dateUTC - J2000)/dayMs) - (lon/360));
      const Jstar = n + lon/360 + 0.0008 + (2440587.5 - 2451545);
      function solNoon(){
        const M = (357.5291 + 0.98560028 * (Jstar - 2451545)) % 360;
        const C = 1.9148*Math.sin(M*rad) + 0.0200*Math.sin(2*M*rad) + 0.0003*Math.sin(3*M*rad);
        const L = (M + 102.9372 + C + 180) % 360;
        return 2451545 + Jstar + 0.0053*Math.sin(M*rad) - 0.0069*Math.sin(2*L*rad);
      }
      function hourAngle(){
        const M = (357.5291 + 0.98560028 * (Jstar - 2451545)) % 360;
        const C = 1.9148*Math.sin(M*rad) + 0.0200*Math.sin(2*M*rad) + 0.0003*Math.sin(3*M*rad);
        const L = (M + 102.9372 + C + 180) % 360;
        const δ = Math.asin(Math.sin(L*rad)*Math.sin(23.44*rad));
        const φ = lat*rad, h0 = (-6)*rad;
        const cosH = (Math.sin(h0) - Math.sin(φ)*Math.sin(δ)) / (Math.cos(φ)*Math.cos(δ));
        if (cosH <= -1) return Math.PI; if (cosH >= 1) return 0; return Math.acos(cosH);
      }
      function jdToDate(jd){ return new Date((jd - 2440587.5)*dayMs); }
      const Jnoon = solNoon();
      const H = hourAngle();
      const Jrise = Jnoon - (H/(2*Math.PI));
      const Jset  = Jnoon + (H/(2*Math.PI));
      return { sunrise: jdToDate(Jrise), sunset: jdToDate(Jset) };
    }

    function isNightNow(lat, lon){
      const now = new Date();
      const { sunrise, sunset } = sunTimes(now, lat, lon);
      return (now < sunrise) || (now > sunset);
    }
    function systemPrefersDark(){
      return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    }
    function applyTheme(theme){
      const html = document.documentElement;
      let resolved = theme;
      if (theme === "auto") {
        try { resolved = isNightNow(CONFIG.lat, CONFIG.lon) ? "dark" : "light"; }
        catch { resolved = systemPrefersDark() ? "dark" : "light"; }
      }
      html.setAttribute("data-theme", resolved);
      const bg = getComputedStyle(html).getPropertyValue("--bg").trim();
      let meta = document.querySelector('meta[name="theme-color"]');
      if (!meta) { meta = document.createElement("meta"); meta.name = "theme-color"; document.head.appendChild(meta); }
      meta.setAttribute("content", bg);
    }

    const saved = localStorage.getItem(STORAGE_KEY) || "auto";
    applyTheme(saved);
    if (selectEl) selectEl.value = saved;
    if (window.matchMedia) {
      window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", () => {
        if ((localStorage.getItem(STORAGE_KEY) || "auto") === "auto") applyTheme("auto");
      });
    }
    setInterval(() => {
      if ((localStorage.getItem(STORAGE_KEY) || "auto") === "auto") applyTheme("auto");
    }, 60*60*1000);
    if (selectEl) {
      selectEl.addEventListener("change", (e) => {
        const value = e.target.value; localStorage.setItem(STORAGE_KEY, value); applyTheme(value);
      });
    }
  })();

  // ---------- Passkey (WebAuthn) + session ----------
  // Expected backend routes (replace as needed):
  // POST /api/auth/register/options     -> { publicKey: {...} }
  // POST /api/auth/register/verify      -> { ok:true }
  // POST /api/auth/login/options        -> { publicKey: {...} }
  // POST /api/auth/login/verify         -> { ok:true, token:"...", user:{...} }
  // GET  /api/ping                      -> { ok:true, now:... }
  // POST /api/notes (Authorization: Bearer <token>)
  const $ = (sel) => document.querySelector(sel);
  const UI = {
    composer: $('#composer'),
    authState: $('#auth-state'),
    btnRegister: $('#btn-register'),
    btnLogin: $('#btn-login'),
    btnLogout: $('#btn-logout')
  };
  const SESSION_KEY = 'admin_token';

  function b64urlToBuf(b64url){
    const pad = '='.repeat((4 - b64url.length % 4) % 4);
    const b64 = (b64url.replace(/-/g,'+').replace(/_/g,'/')) + pad;
    const raw = atob(b64);
    const buf = new ArrayBuffer(raw.length);
    const view = new Uint8Array(buf);
    for (let i=0;i<raw.length;i++) view[i] = raw.charCodeAt(i);
    return buf;
  }
  function bufToB64url(buf){
    const bytes = new Uint8Array(buf);
    let bin = ''; for (let i=0;i<bytes.length;i++) bin += String.fromCharCode(bytes[i]);
    return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }

  function setSession(token){
    if (token) localStorage.setItem(SESSION_KEY, token);
    else localStorage.removeItem(SESSION_KEY);
    refreshAuthUI();
  }
  function getSession(){ return localStorage.getItem(SESSION_KEY) || null; }

  function refreshAuthUI(){
    const authed = !!getSession();
    UI.composer.style.display = authed ? 'block' : 'none';
    UI.authState.textContent = authed ? 'Signed in' : 'Signed out';
  }

  async function passkeyRegister(){
    try{
      const r1 = await fetch('/api/auth/register/options', {method:'POST'});
      if (!r1.ok) throw new Error('register/options failed');
      const { publicKey } = await r1.json();

      // Decode binary fields
      publicKey.challenge = b64urlToBuf(publicKey.challenge);
      if (publicKey.user && publicKey.user.id) publicKey.user.id = b64urlToBuf(publicKey.user.id);
      if (publicKey.excludeCredentials) {
        publicKey.excludeCredentials = publicKey.excludeCredentials.map(c=>({ ...c, id: b64urlToBuf(c.id) }));
      }

      const cred = await navigator.credentials.create({ publicKey });
      const attObj = cred.response.attestationObject;
      const clientDataJSON = cred.response.clientDataJSON;

      const r2 = await fetch('/api/auth/register/verify', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          id: cred.id,
          rawId: bufToB64url(cred.rawId),
          type: cred.type,
          response: {
            attestationObject: bufToB64url(attObj),
            clientDataJSON: bufToB64url(clientDataJSON)
          }
        })
      });
      const out = await r2.json();
      log('register/verify →', out);
      if (!r2.ok || !out.ok) throw new Error('Registration verify failed');
      alert('Passkey registered.');
    }catch(err){ log('register error:', err.message || err); alert('Register failed'); }
  }

  async function passkeyLogin(){
    try{
      const r1 = await fetch('/api/auth/login/options', {method:'POST'});
      if (!r1.ok) throw new Error('login/options failed');
      const { publicKey } = await r1.json();

      // Decode
      publicKey.challenge = b64urlToBuf(publicKey.challenge);
      if (publicKey.allowCredentials) {
        publicKey.allowCredentials = publicKey.allowCredentials.map(c=>({ ...c, id: b64urlToBuf(c.id) }));
      }

      const cred = await navigator.credentials.get({ publicKey });
      const authData = cred.response.authenticatorData;
      const clientDataJSON = cred.response.clientDataJSON;
      const sig = cred.response.signature;
      const userHandle = cred.response.userHandle;

      const r2 = await fetch('/api/auth/login/verify', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          id: cred.id,
          rawId: bufToB64url(cred.rawId),
          type: cred.type,
          response: {
            authenticatorData: bufToB64url(authData),
            clientDataJSON: bufToB64url(clientDataJSON),
            signature: bufToB64url(sig),
            userHandle: userHandle ? bufToB64url(userHandle) : null
          }
        })
      });
      const out = await r2.json();
      log('login/verify →', out);
      if (!r2.ok || !out.ok || !out.token) throw new Error('Login verify failed');
      setSession(out.token);
    }catch(err){ log('login error:', err.message || err); alert('Login failed'); }
  }

  // Wire auth buttons
  UI.btnRegister?.addEventListener('click', passkeyRegister);
  UI.btnLogin?.addEventListener('click', passkeyLogin);
  UI.btnLogout?.addEventListener('click', ()=> setSession(null));
  refreshAuthUI();

  // ---------- Debug buttons ----------
  $('#dbg-ping')?.addEventListener('click', async ()=>{
    try{
      const r = await fetch('/api/ping', { headers:{ 'Authorization': getSession()? `Bearer ${getSession()}` : '' } });
      const j = await r.json();
      log('ping →', j);
    }catch(e){ log('ping error →', e?.message || e); }
  });
  $('#dbg-session')?.addEventListener('click', ()=> log('session →', { token: getSession() }));
  $('#dbg-clear')?.addEventListener('click', ()=> { if(dbg) dbg.value=''; });

  // ---------- Save handler ----------
  document.getElementById('note-form')?.addEventListener('submit', async (e)=>{
    e.preventDefault();
    const token = getSession();
    if (!token) { alert('Sign in first.'); return; }

    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const createdUtc = new Date().toISOString(); // canonical UTC
    const payload = {
      body: bodyEl.value,
      created_at: createdUtc,     // store UTC ISO
      tz: tz                      // store IANA tz for display
    };

    try{
      const r = await fetch('/api/notes', {
        method:'POST',
        headers:{ 'Content-Type':'application/json', 'Authorization': `Bearer ${token}` },
        body: JSON.stringify(payload)
      });
      const j = await r.json();
      log('save →', j);
      if (!r.ok) throw new Error('Save failed');
      alert('Saved.');
      bodyEl.value = '';
      renderPreview();
    }catch(err){ log('save error:', err?.message || err); alert('Save failed'); }
  });
</script>
</body>
</html>
